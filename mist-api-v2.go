// Code generated by openapi-cli-generator. DO NOT EDIT.
// See https://gitlab.ops.mist.io/mistio/openapi-cli-generator

package main

import (
	"fmt"
	"strings"

	"github.com/mistio/cobra"
	"github.com/pkg/errors"
	"github.com/spf13/viper"
	"gitlab.ops.mist.io/mistio/openapi-cli-generator/cli"
	"gopkg.in/h2non/gentleman.v2"
)

var mistApiV2Subcommand bool

func mistApiV2Servers() []map[string]string {
	return []map[string]string{

		map[string]string{
			"description": "Mist Hosted Service",
			"url":         "https://mist.io/",
		},
	}
}

func setMistContext() error {
	mistContext := viper.GetString("context")
	mistContextDefault := cli.Creds.GetString("default.context")
	if mistContext == "" {
		if mistContextDefault == "" {
			mistContexts := cli.Creds.GetStringMap("contexts")
			if len(mistContexts) == 0 {
				return errors.Errorf("No contexts configured. Use `%s config add-context` to add one.", cli.Root.CommandPath())
			}
			for k, _ := range mistContexts {
				mistContext = k
				break
			}
		} else {
			mistContext = mistContextDefault
		}
	}
	if cli.ExistsMistContext(mistContext) {
		viper.Set("context", mistContext)
		if mistContextDefault == "" {
			cli.UpdateDefaultMistContext(mistContext)
		}
		return nil
	}
	return errors.Errorf("Context %s not configured. Use `%s config add-context` to add it.", mistContext, cli.Root.CommandPath())
}

func getServer() (string, error) {
	server := viper.GetString("server")
	if server == "" {
		var ok bool
		server, ok = cli.GetMistContext()["server"]
		if !ok {
			server = cli.Creds.GetString("default.server")
			if server == "" {
				if len(mistApiV2Servers()) > 0 {
					server = mistApiV2Servers()[0]["url"]
					cli.UpdateDefaultServer(server)
				} else {
					return "", errors.Errorf("No default server url found.")
				}
			}
		}
	}
	return server, nil
}

func getToken() (string, error) {
	err := setMistContext()
	if err != nil {
		return "", err
	}
	mistContext := cli.Creds.GetString("default.context")
	return cli.Creds.GetString("contexts." + mistContext + ".api_key"), nil
}

// MistApiV2ListClouds List clouds
func MistApiV2ListClouds(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-clouds"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds"

	req := cli.Client.Get().URL(url)

	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "provider", "tags"}, []string{"id", "name", "provider", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2AddCloud Add cloud
func MistApiV2AddCloud(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "add-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteCloud Delete cloud
func MistApiV2DeleteCloud(paramCloud string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds/{cloud}"
	url = strings.Replace(url, "{cloud}", paramCloud, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetCloud Get cloud
func MistApiV2GetCloud(paramCloud string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds/{cloud}"
	url = strings.Replace(url, "{cloud}", paramCloud, 1)

	req := cli.Client.Get().URL(url)

	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "provider", "tags"}, []string{"id", "name", "provider", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2EditCloud Edit cloud
func MistApiV2EditCloud(paramCloud string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds/{cloud}"
	url = strings.Replace(url, "{cloud}", paramCloud, 1)

	req := cli.Client.Put().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListImages List images
func MistApiV2ListImages(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-images"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/images"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"starred", "name", "cloud", "os_type", "tags"}, []string{"starred", "id", "external_id", "name", "cloud", "os_type", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2GetImage Get image
func MistApiV2GetImage(paramImage string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-image"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/images/{image}"
	url = strings.Replace(url, "{image}", paramImage, 1)

	req := cli.Client.Get().URL(url)

	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"starred", "name", "cloud", "os_type", "tags"}, []string{"starred", "id", "external_id", "name", "cloud", "os_type", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2ListKeys List keys
func MistApiV2ListKeys(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-keys"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/keys"

	req := cli.Client.Get().URL(url)

	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "default", "tags"}, []string{"id", "name", "default", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2AddKey Add key
func MistApiV2AddKey(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "add-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/keys"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteKey Delete key
func MistApiV2DeleteKey(paramKey string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/keys/{key}"
	url = strings.Replace(url, "{key}", paramKey, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetKey Get key
func MistApiV2GetKey(paramKey string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/keys/{key}"
	url = strings.Replace(url, "{key}", paramKey, 1)

	req := cli.Client.Get().URL(url)

	paramPrivate := params.GetBool("private")
	if paramPrivate != false {
		req = req.AddQuery("private", fmt.Sprintf("%v", paramPrivate))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "default", "tags"}, []string{"id", "name", "default", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2EditKey Edit key
func MistApiV2EditKey(paramKey string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/keys/{key}"
	url = strings.Replace(url, "{key}", paramKey, 1)

	req := cli.Client.Put().URL(url)

	paramName := params.GetString("name")
	if paramName != "" {
		req = req.AddQuery("name", fmt.Sprintf("%v", paramName))
	}
	paramDefault := params.GetBool("default")
	if paramDefault != false {
		req = req.AddQuery("default", fmt.Sprintf("%v", paramDefault))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListLocations List locations
func MistApiV2ListLocations(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-locations"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/locations"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud"}, []string{"id", "name", "cloud", "external_id", "machines"}}, nil
}

// MistApiV2GetLocation Get location
func MistApiV2GetLocation(paramLocation string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-location"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/locations/{location}"
	url = strings.Replace(url, "{location}", paramLocation, 1)

	req := cli.Client.Get().URL(url)

	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud"}, []string{"id", "name", "cloud", "locations", "external_id", "machines"}}, nil
}

// MistApiV2ListMachines List machines
func MistApiV2ListMachines(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-machines"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud", "state", "tags"}, []string{"id", "name", "state", "cloud", "external_id", "public_ips", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2CreateMachine Create machine
func MistApiV2CreateMachine(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2EditMachine Edit machine
func MistApiV2EditMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Put().URL(url)

	paramName := params.GetString("name")
	if paramName != "" {
		req = req.AddQuery("name", fmt.Sprintf("%v", paramName))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetMachine Get machine
func MistApiV2GetMachine(paramMachine string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Get().URL(url)

	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud", "state", "tags"}, []string{"id", "name", "state", "cloud", "external_id", "public_ips", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2CloneMachine Clone machine
func MistApiV2CloneMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "clone-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/clone"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2Console Open console
func MistApiV2Console(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "console"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/console"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DestroyMachine Destroy machine
func MistApiV2DestroyMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "destroy-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/destroy"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ExposeMachine Expose machine
func MistApiV2ExposeMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "expose-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/expose"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2RebootMachine Reboot machine
func MistApiV2RebootMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "reboot-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/reboot"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2RenameMachine Rename machine
func MistApiV2RenameMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "rename-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/rename"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ResizeMachine Resize machine
func MistApiV2ResizeMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "resize-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/resize"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ResumeMachine Resume machine
func MistApiV2ResumeMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "resume-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/resume"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2StartMachine Start machine
func MistApiV2StartMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "start-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/start"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2StopMachine Stop machine
func MistApiV2StopMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "stop-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/stop"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2SuspendMachine Suspend machine
func MistApiV2SuspendMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "suspend-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/suspend"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2UndefineMachine Undefine machine
func MistApiV2UndefineMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "undefine-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/undefine"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListSnapshots Suspend machine
func MistApiV2ListSnapshots(paramMachine string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-snapshots"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/snapshots"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2CreateSnapshot Create snapshot
func MistApiV2CreateSnapshot(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-snapshot"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/snapshots"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2RemoveSnapshot Remove snapshot
func MistApiV2RemoveSnapshot(paramMachine string, paramSnapshot string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "remove-snapshot"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/snapshots/{snapshot}"
	url = strings.Replace(url, "{machine}", paramMachine, 1)
	url = strings.Replace(url, "{snapshot}", paramSnapshot, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2RevertToSnapshot Revert to snapshot
func MistApiV2RevertToSnapshot(paramMachine string, paramSnapshot string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "revert-to-snapshot"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/snapshots/{snapshot}"
	url = strings.Replace(url, "{machine}", paramMachine, 1)
	url = strings.Replace(url, "{snapshot}", paramSnapshot, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListNetworks List networks
func MistApiV2ListNetworks(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-networks"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/networks"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud", "machines", "tags"}, []string{"id", "name", "cloud", "external_id", "machines", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2CreateNetwork Create network
func MistApiV2CreateNetwork(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-network"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/networks"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetNetwork Get network
func MistApiV2GetNetwork(paramNetwork string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-network"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/networks/{network}"
	url = strings.Replace(url, "{network}", paramNetwork, 1)

	req := cli.Client.Get().URL(url)

	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud", "machines", "tags"}, []string{"id", "name", "cloud", "location", "external_id", "subnets", "machines", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2EditNetwork Edit network
func MistApiV2EditNetwork(paramNetwork string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-network"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/networks/{network}"
	url = strings.Replace(url, "{network}", paramNetwork, 1)

	req := cli.Client.Put().URL(url)

	paramName := params.GetString("name")
	if paramName != "" {
		req = req.AddQuery("name", fmt.Sprintf("%v", paramName))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListRules List rules
func MistApiV2ListRules(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-rules"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/rules"

	req := cli.Client.Get().URL(url)

	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"title", "queries", "actions", "tags"}, []string{"id", "title", "resource_type", "selectors", "queries", "actions", "window", "frequency", "tags"}}, nil
}

// MistApiV2AddRule Add rule
func MistApiV2AddRule(paramQueries string, paramWindow string, paramFrequency string, paramTriggerAfter string, paramActions string, paramSelectors string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "add-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/rules"

	req := cli.Client.Post().URL(url)

	req = req.AddQuery("queries", paramQueries)

	req = req.AddQuery("window", paramWindow)

	req = req.AddQuery("frequency", paramFrequency)

	req = req.AddQuery("trigger_after", paramTriggerAfter)

	req = req.AddQuery("actions", paramActions)

	req = req.AddQuery("selectors", paramSelectors)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteRule Delete rule
func MistApiV2DeleteRule(paramRule string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetRule Get rule
func MistApiV2GetRule(paramRule string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Get().URL(url)

	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"title", "queries", "actions", "tags"}, []string{"id", "title", "resource_type", "selectors", "queries", "actions", "window", "frequency", "tags"}}, nil
}

// MistApiV2RenameRule Rename rule
func MistApiV2RenameRule(paramRule string, paramAction string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "rename-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Patch().URL(url)

	req = req.AddQuery("action", paramAction)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2UpdateRule Update rule
func MistApiV2UpdateRule(paramRule string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "update-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Post().URL(url)

	paramQueries := params.GetString("queries")
	if paramQueries != "" {
		req = req.AddQuery("queries", fmt.Sprintf("%v", paramQueries))
	}
	paramWindow := params.GetString("window")
	if paramWindow != "" {
		req = req.AddQuery("window", fmt.Sprintf("%v", paramWindow))
	}
	paramFrequency := params.GetString("frequency")
	if paramFrequency != "" {
		req = req.AddQuery("frequency", fmt.Sprintf("%v", paramFrequency))
	}
	paramTriggerAfter := params.GetString("trigger-after")
	if paramTriggerAfter != "" {
		req = req.AddQuery("trigger_after", fmt.Sprintf("%v", paramTriggerAfter))
	}
	paramActions := params.GetString("actions")
	if paramActions != "" {
		req = req.AddQuery("actions", fmt.Sprintf("%v", paramActions))
	}
	paramSelectors := params.GetString("selectors")
	if paramSelectors != "" {
		req = req.AddQuery("selectors", fmt.Sprintf("%v", paramSelectors))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ToggleRule Toggle rule
func MistApiV2ToggleRule(paramRule string, paramAction string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "toggle-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Put().URL(url)

	req = req.AddQuery("action", paramAction)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListScripts List scripts
func MistApiV2ListScripts(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-scripts"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/scripts"

	req := cli.Client.Get().URL(url)

	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "tags"}, []string{"id", "name", "description", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2DeleteScript Delete script
func MistApiV2DeleteScript(paramScript string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-script"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/scripts/{script}"
	url = strings.Replace(url, "{script}", paramScript, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetScript Get script
func MistApiV2GetScript(paramScript string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-script"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/scripts/{script}"
	url = strings.Replace(url, "{script}", paramScript, 1)

	req := cli.Client.Get().URL(url)

	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "tags"}, []string{"id", "name", "description", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2EditScript Edit script
func MistApiV2EditScript(paramScript string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-script"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/scripts/{script}"
	url = strings.Replace(url, "{script}", paramScript, 1)

	req := cli.Client.Put().URL(url)

	paramName := params.GetString("name")
	if paramName != "" {
		req = req.AddQuery("name", fmt.Sprintf("%v", paramName))
	}
	paramDescription := params.GetString("description")
	if paramDescription != "" {
		req = req.AddQuery("description", fmt.Sprintf("%v", paramDescription))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListSizes List sizes
func MistApiV2ListSizes(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-sizes"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/sizes"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud"}, []string{"id", "name", "cloud", "external_id", "machines"}}, nil
}

// MistApiV2GetSize Get size
func MistApiV2GetSize(paramSize string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-size"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/sizes/{size}"
	url = strings.Replace(url, "{size}", paramSize, 1)

	req := cli.Client.Get().URL(url)

	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud"}, []string{"id", "name", "cloud", "locations", "external_id", "machines"}}, nil
}

// MistApiV2ListVolumes List volumes
func MistApiV2ListVolumes(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-volumes"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/volumes"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "size", "cloud", "location", "attached_to", "tags"}, []string{"id", "name", "size", "cloud", "location", "external_id", "attached_to", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2CreateVolume Create volume
func MistApiV2CreateVolume(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-volume"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/volumes"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetVolume Get volume
func MistApiV2GetVolume(paramVolume string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-volume"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/volumes/{volume}"
	url = strings.Replace(url, "{volume}", paramVolume, 1)

	req := cli.Client.Get().URL(url)

	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "size", "cloud", "location", "attached_to", "tags"}, []string{"id", "name", "size", "cloud", "location", "external_id", "attached_to", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2EditVolume Edit volume
func MistApiV2EditVolume(paramVolume string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-volume"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/volumes/{volume}"
	url = strings.Replace(url, "{volume}", paramVolume, 1)

	req := cli.Client.Put().URL(url)

	paramName := params.GetString("name")
	if paramName != "" {
		req = req.AddQuery("name", fmt.Sprintf("%v", paramName))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListZones List zones
func MistApiV2ListZones(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-zones"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/zones"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud", "machines", "tags"}, []string{"id", "name", "cloud", "external_id", "machines", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2CreateZone Create zone
func MistApiV2CreateZone(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-zone"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/zones"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetZone Get zone
func MistApiV2GetZone(paramZone string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-zone"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/zones/{zone}"
	url = strings.Replace(url, "{zone}", paramZone, 1)

	req := cli.Client.Get().URL(url)

	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud", "machines", "tags"}, []string{"id", "name", "cloud", "location", "external_id", "subnets", "machines", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2EditZone Edit zone
func MistApiV2EditZone(paramZone string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-zone"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/zones/{zone}"
	url = strings.Replace(url, "{zone}", paramZone, 1)

	req := cli.Client.Put().URL(url)

	paramName := params.GetString("name")
	if paramName != "" {
		req = req.AddQuery("name", fmt.Sprintf("%v", paramName))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

func mistApiV2Register(subcommand bool) {
	root := cli.Root

	if subcommand {
		root = &cobra.Command{
			Use:   "Mist CLI",
			Short: "Mist API",
			Long:  cli.Markdown(""),
		}
		mistApiV2Subcommand = true
	} else {
		cli.Root.Short = "Mist API"
		cli.Root.Long = cli.Markdown("")
	}

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-clouds",
			Short:   "List clouds",
			Long:    cli.Markdown("List clouds owned by the active org. READ permission required on cloud."),
			Example: examples,
			Group:   "clouds",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListClouds(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "add-cloud",
			Short:   "Add cloud",
			Long:    cli.Markdown("Adds a new cloud and returns the cloud's id. ADD permission required on cloud.\n## Request Schema (application/json)\n\nallOf:\n- properties:\n    provider:\n      description: The provider of the cloud\n      enum:\n      - alibaba\n      - amazon\n      - azure\n      - cloudsigma\n      - digitalocean\n      - equinix\n      - google\n      - ibm\n      - kvm\n      - kubevirt\n      - linode\n      - lxd\n      - maxihost\n      - onapp\n      - openstack\n      - other\n      - rackspace\n      - vcloud\n      - vsphere\n      - vultr\n      type: string\n    title:\n      description: The name of the cloud to add\n      type: string\n  required:\n  - title\n  - provider\n  type: object\n- discriminator:\n    mapping:\n      alibaba: '#/components/schemas/AddAlibabaCloudRequest'\n      amazon: '#/components/schemas/AddAmazonCloudRequest'\n      azure: '#/components/schemas/AddAzureCloudRequest'\n      cloudsigma: '#/components/schemas/AddCloudSigmaCloudRequest'\n      docker: '#/components/schemas/AddDockerCloudRequest'\n      equinix: '#/components/schemas/AddEquinixCloudRequest'\n      google: '#/components/schemas/AddGoogleCloudRequest'\n      ibm: '#/components/schemas/AddIbmCloudRequest'\n      kubevirt: '#/components/schemas/AddKubevirtCloudRequest'\n      kvm: '#/components/schemas/AddKvmCloudRequest'\n      linode: '#/components/schemas/AddLinodeCloudRequest'\n      lxd: '#/components/schemas/AddLxdCloudRequest'\n      maxihost: '#/components/schemas/AddMaxihostCloudRequest'\n      onapp: '#/components/schemas/AddOnappCloudRequest'\n      openstack: '#/components/schemas/AddOpenstackCloudRequest'\n      other: '#/components/schemas/AddOtherCloudRequest'\n      rackspace: '#/components/schemas/AddRackspaceCloudRequest'\n      vcloud: '#/components/schemas/AddVcloudCloudRequest'\n      vsphere: '#/components/schemas/AddVsphereCloudRequest'\n      vultr: '#/components/schemas/AddVultrCloudRequest'\n    propertyName: provider\n  oneOf:\n  - $ref: '#/components/schemas/AddAmazonCloudRequest'\n  - $ref: '#/components/schemas/AddAzureCloudRequest'\n  - $ref: '#/components/schemas/AddGoogleCloudRequest'\n  - $ref: '#/components/schemas/AddAlibabaCloudRequest'\n  - $ref: '#/components/schemas/AddCloudSigmaCloudRequest'\n  - $ref: '#/components/schemas/AddEquinixCloudRequest'\n  - $ref: '#/components/schemas/AddIbmCloudRequest'\n  - $ref: '#/components/schemas/AddDigitaloceanCloudRequest'\n  - $ref: '#/components/schemas/AddLinodeCloudRequest'\n  - $ref: '#/components/schemas/AddRackspaceCloudRequest'\n  - $ref: '#/components/schemas/AddMaxihostCloudRequest'\n  - $ref: '#/components/schemas/AddVultrCloudRequest'\n  - $ref: '#/components/schemas/AddOpenstackCloudRequest'\n  - $ref: '#/components/schemas/AddOnappCloudRequest'\n  - $ref: '#/components/schemas/AddVsphereCloudRequest'\n  - $ref: '#/components/schemas/AddVcloudCloudRequest'\n  - $ref: '#/components/schemas/AddKvmCloudRequest'\n  - $ref: '#/components/schemas/AddLxdCloudRequest'\n  - $ref: '#/components/schemas/AddDockerCloudRequest'\n  - $ref: '#/components/schemas/AddKubevirtCloudRequest'\n  - $ref: '#/components/schemas/AddOtherCloudRequest'\n"),
			Example: examples,
			Group:   "clouds",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2AddCloud(params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-cloud cloud",
			Short:   "Delete cloud",
			Long:    cli.Markdown("Delete target cloud"),
			Example: examples,
			Group:   "clouds",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2DeleteCloud(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-cloud cloud",
			Short:   "Get cloud",
			Long:    cli.Markdown("Get details about target cloud"),
			Example: examples,
			Group:   "clouds",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetCloud(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-cloud cloud",
			Short:   "Edit cloud",
			Long:    cli.Markdown("Update target cloud title or credentials\n## Request Schema (application/json)\n\nproperties:\n  credentials:\n    $ref: '#/components/schemas/CloudCredentials'\n  features:\n    $ref: '#/components/schemas/CloudFeatures'\n  title:\n    description: Updated title\n    type: string\ntype: object\n"),
			Example: examples,
			Group:   "clouds",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2EditCloud(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-images",
			Short:   "List images",
			Long:    cli.Markdown("List images owned by the active org. READ permission required on image & cloud."),
			Example: examples,
			Group:   "images",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListImages(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-image image",
			Short:   "Get image",
			Long:    cli.Markdown("Get details about target image"),
			Example: examples,
			Group:   "images",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetImage(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-keys",
			Short:   "List keys",
			Long:    cli.Markdown("List keys owned by the active org. READ permission required on key."),
			Example: examples,
			Group:   "keys",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListKeys(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "add-key",
			Short:   "Add key",
			Long:    cli.Markdown("Adds a new key and returns the key's id. ADD permission required on key.\n## Request Schema (application/json)\n\nanyOf:\n- properties:\n    certificate:\n      description: The signed public key, when using signed ssh keys\n      type: string\n    name:\n      description: The key's name\n      type: string\n    private:\n      description: The private key\n      type: string\n  required:\n  - name\n  - private\n- properties:\n    dry:\n      description: Return generated key without actually adding it\n      type: boolean\n    generate:\n      description: Generate a keypair instead of providing one\n      type: boolean\n    name:\n      description: The key's name\n      type: string\n  required:\n  - name\n  - generate\n- properties:\n    dry:\n      description: Return generated key without actually adding it\n      type: boolean\n    generate:\n      description: Generate a keypair instead of providing one\n      type: boolean\n  required:\n  - generate\n  - dry\ntype: object\n"),
			Example: examples,
			Group:   "keys",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2AddKey(params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-key key",
			Short:   "Delete key",
			Long:    cli.Markdown("Delete target key"),
			Example: examples,
			Group:   "keys",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2DeleteKey(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-key key",
			Short:   "Get key",
			Long:    cli.Markdown("Get details about target key"),
			Example: examples,
			Group:   "keys",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetKey(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("private", "", "Return the private key. Requires READ_PRIVATE permission on key.")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-key key",
			Short:   "Edit key",
			Long:    cli.Markdown("Edit target key"),
			Example: examples,
			Group:   "keys",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2EditKey(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New key name")
		cmd.Flags().String("default", "", "Set as default")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-locations",
			Short:   "List locations",
			Long:    cli.Markdown("List locations owned by the active org. READ permission required on location & cloud."),
			Example: examples,
			Group:   "locations",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListLocations(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-location location",
			Short:   "Get location",
			Long:    cli.Markdown("Get details about target location"),
			Example: examples,
			Group:   "locations",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetLocation(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-machines",
			Short:   "List machines",
			Long:    cli.Markdown("List machines owned by the active org. READ permission required on machine & cloud."),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListMachines(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-machine",
			Short:   "Create machine",
			Long:    cli.Markdown("Creates one or more machines on the specified cloud. If async is true, a jobId will be returned. READ permission required on cloud. CREATE_RESOURCES permission required on cloud. READ permission required on location. CREATE_RESOURCES permission required on location. CREATE permission required on machine. RUN permission required on script. READ permission required on key.\n## Request Schema (application/json)\n\nproperties:\n  cloud:\n    description: Specify cloud to provision on\n    type: string\n  cloudinit:\n    description: Run this Cloud Init script on first boot\n    type: string\n  disks:\n    description: Configure local disks\n    type: object\n  dry:\n    description: Return provisioning plan and exit without executing it\n    type: boolean\n  expiration:\n    $ref: '#/components/schemas/Expiration'\n  extra:\n    description: Configure additional parameters\n    type: object\n  fqdn:\n    description: Add DNS A Record that points machine's public IP to this Fully Qualified\n      Domain Name. Zone needs to be managed by a configured Cloud DNS provider\n    type: string\n  image:\n    description: Operating System image to boot from\n    type: object\n  key:\n    description: Associate SSH key\n    type: object\n  location:\n    description: Where to provision e.g. region, datacenter, rack\n    type: string\n  monitoring:\n    description: Enable monitoring of this machine\n    type: boolean\n  name:\n    description: Specify machine name\n    type: string\n  net:\n    description: Specify network configuration parameters\n    type: object\n  provider:\n    $ref: '#/components/schemas/SupportedProviders'\n  quantity:\n    description: Provision multiple machines of this type\n    type: number\n  save:\n    description: Save provisioning plan as template\n    type: boolean\n  schedules:\n    allOf:\n    - properties:\n        action:\n          enum:\n          - start\n          - stop\n          - reboot\n          - destroy\n          type: string\n        description:\n          type: string\n        schedule_type:\n          enum:\n          - one_off\n          - crontab\n          - interval\n          type: string\n        script:\n          $ref: '#/components/schemas/PostDeployScript'\n      required:\n      - schedule_type\n      type: object\n    - discriminator:\n        mapping:\n          crontab: '#/components/schemas/CronSchedule'\n          interval: '#/components/schemas/IntervalSchedule'\n          one_off: '#/components/schemas/OneOffSchedule'\n        propertyName: schedule_type\n      oneOf:\n      - $ref: '#/components/schemas/OneOffSchedule'\n      - $ref: '#/components/schemas/CronSchedule'\n      - $ref: '#/components/schemas/IntervalSchedule'\n    description: Configure scheduled actions for the provisioned machine\n  scripts:\n    description: Run post deploy scripts over SSH\n    items:\n      allOf:\n      - type: object\n      - oneOf:\n        - $ref: '#/components/schemas/InlineScript'\n        - $ref: '#/components/schemas/PostDeployScript'\n    type: array\n  size:\n    description: Machine sizing spec e.g. cpu/ram/flavor\n    type: object\n  tags:\n    description: Assign tags to provisioned machine\n    type: object\n  template:\n    type: object\n  volumes:\n    description: Configure of attached storage volumes, e.g. cloud disks\n    items:\n      type: object\n    type: array\nrequired:\n- name\n- size\n- image\ntype: object\n"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2CreateMachine(params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-machine machine",
			Short:   "Edit machine",
			Long:    cli.Markdown("Edit target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2EditMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New machine name")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-machine machine",
			Short:   "Get machine",
			Long:    cli.Markdown("Get details about target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetMachine(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "clone-machine machine",
			Short:   "Clone machine",
			Long:    cli.Markdown("Clone target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2CloneMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "console machine",
			Short:   "Open console",
			Long:    cli.Markdown("Open VNC console on target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2Console(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "destroy-machine machine",
			Short:   "Destroy machine",
			Long:    cli.Markdown("Destroy target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2DestroyMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "expose-machine machine",
			Short:   "Expose machine",
			Long:    cli.Markdown("Expose target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2ExposeMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "reboot-machine machine",
			Short:   "Reboot machine",
			Long:    cli.Markdown("Reboot target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2RebootMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "rename-machine machine",
			Short:   "Rename machine",
			Long:    cli.Markdown("Rename target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2RenameMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "resize-machine machine",
			Short:   "Resize machine",
			Long:    cli.Markdown("Resize target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2ResizeMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "resume-machine machine",
			Short:   "Resume machine",
			Long:    cli.Markdown("Resume target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2ResumeMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "start-machine machine",
			Short:   "Start machine",
			Long:    cli.Markdown("Start target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2StartMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "stop-machine machine",
			Short:   "Stop machine",
			Long:    cli.Markdown("Stop target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2StopMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "suspend-machine machine",
			Short:   "Suspend machine",
			Long:    cli.Markdown("Suspend target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2SuspendMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "undefine-machine machine",
			Short:   "Undefine machine",
			Long:    cli.Markdown("Undefine target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2UndefineMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-snapshots machine",
			Short:   "Suspend machine",
			Long:    cli.Markdown("List snapshots of target machine"),
			Example: examples,
			Group:   "snapshots",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListSnapshots(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-snapshot machine",
			Short:   "Create snapshot",
			Long:    cli.Markdown("Create snapshots of target machine"),
			Example: examples,
			Group:   "snapshots",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2CreateSnapshot(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "remove-snapshot machine snapshot",
			Short:   "Remove snapshot",
			Long:    cli.Markdown("Remove target machine snapshot"),
			Example: examples,
			Group:   "snapshots",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2RemoveSnapshot(args[0], args[1], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "revert-to-snapshot machine snapshot",
			Short:   "Revert to snapshot",
			Long:    cli.Markdown("Revert machine to snapshot"),
			Example: examples,
			Group:   "snapshots",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[2:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2RevertToSnapshot(args[0], args[1], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-networks",
			Short:   "List networks",
			Long:    cli.Markdown("List networks owned by the active org. READ permission required on network & cloud."),
			Example: examples,
			Group:   "networks",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListNetworks(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-network",
			Short:   "Create network",
			Long:    cli.Markdown("Creates one or more networks on the specified cloud. If async is true, a jobId will be returned. READ permission required on cloud. CREATE_RESOURCES permission required on cloud. CREATE permission required on network.\n## Request Schema (application/json)\n\nproperties:\n  cloud:\n    description: Specify cloud to provision on\n    type: string\n  dry:\n    description: Return provisioning plan and exit without executing it\n    type: boolean\n  extra:\n    description: Configure additional parameters\n    type: object\n  name:\n    description: Specify network name\n    type: string\n  save:\n    description: Save provisioning plan as template\n    type: boolean\n  tags:\n    description: Assign tags to provisioned network\n    type: object\n  template:\n    type: object\nrequired:\n- name\n- cloud\ntype: object\n"),
			Example: examples,
			Group:   "networks",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2CreateNetwork(params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-network network",
			Short:   "Get network",
			Long:    cli.Markdown("Get details about target network"),
			Example: examples,
			Group:   "networks",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetNetwork(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-network network",
			Short:   "Edit network",
			Long:    cli.Markdown("Edit target network"),
			Example: examples,
			Group:   "networks",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2EditNetwork(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New network name")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-rules",
			Short:   "List rules",
			Long:    cli.Markdown("Return a filtered list of rules"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListRules(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "add-rule queries window frequency trigger-after actions selectors",
			Short:   "Add rule",
			Long:    cli.Markdown("Add a new rule, READ permission required on target resource, ADD permission required on Rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(6),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[6:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2AddRule(args[0], args[1], args[2], args[3], args[4], args[5], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-rule rule",
			Short:   "Delete rule",
			Long:    cli.Markdown("Delete a rule given its UUID."),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2DeleteRule(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-rule rule",
			Short:   "Get rule",
			Long:    cli.Markdown("Get details about target rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetRule(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("only", "", "Only return these fields")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "rename-rule rule action",
			Short:   "Rename rule",
			Long:    cli.Markdown("Rename a rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[2:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2RenameRule(args[0], args[1], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "update-rule rule",
			Short:   "Update rule",
			Long:    cli.Markdown("Update a rule given its UUID, EDIT permission required on rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2UpdateRule(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("queries", "", "")
		cmd.Flags().String("window", "", "")
		cmd.Flags().String("frequency", "", "")
		cmd.Flags().String("trigger-after", "", "")
		cmd.Flags().String("actions", "", "")
		cmd.Flags().String("selectors", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "toggle-rule rule action",
			Short:   "Toggle rule",
			Long:    cli.Markdown("Enable or disable a rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[2:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2ToggleRule(args[0], args[1], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-scripts",
			Short:   "List scripts",
			Long:    cli.Markdown("List scripts owned by the active org. READ permission required on script."),
			Example: examples,
			Group:   "scripts",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListScripts(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-script script",
			Short:   "Delete script",
			Long:    cli.Markdown("Delete target script"),
			Example: examples,
			Group:   "scripts",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2DeleteScript(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-script script",
			Short:   "Get script",
			Long:    cli.Markdown("Get details about target script"),
			Example: examples,
			Group:   "scripts",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetScript(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-script script",
			Short:   "Edit script",
			Long:    cli.Markdown("Edit target script"),
			Example: examples,
			Group:   "scripts",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2EditScript(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New script name")
		cmd.Flags().String("description", "", "New script description")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-sizes",
			Short:   "List sizes",
			Long:    cli.Markdown("List sizes owned by the active org. READ permission required on size & cloud."),
			Example: examples,
			Group:   "sizes",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListSizes(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-size size",
			Short:   "Get size",
			Long:    cli.Markdown("Get details about target size"),
			Example: examples,
			Group:   "sizes",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetSize(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-volumes",
			Short:   "List volumes",
			Long:    cli.Markdown("List volumes owned by the active org. READ permission required on volume & cloud."),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListVolumes(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-volume",
			Short:   "Create volume",
			Long:    cli.Markdown("Creates one or more volumes on the specified cloud. If async is true, a jobId will be returned. READ permission required on cloud. CREATE_RESOURCES permission required on cloud. READ permission required on location. CREATE_RESOURCES permission required on location. CREATE permission required on volume.\n## Request Schema (application/json)\n\nproperties:\n  cloud:\n    description: Specify cloud to provision on\n    type: string\n  dry:\n    description: Return provisioning plan and exit without executing it\n    type: boolean\n  extra:\n    description: Configure additional parameters\n    type: object\n  location:\n    description: Where to provision e.g. region, datacenter, rack\n    type: string\n  name:\n    description: Specify volume name\n    type: string\n  provider:\n    $ref: '#/components/schemas/SupportedProviders'\n  quantity:\n    description: Provision multiple volumes of this type\n    type: number\n  save:\n    description: Save provisioning plan as template\n    type: boolean\n  size:\n    description: Volume sizing spec\n    type: object\n  tags:\n    description: Assign tags to provisioned volume\n    type: object\n  template:\n    type: object\nrequired:\n- name\n- size\ntype: object\n"),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2CreateVolume(params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-volume volume",
			Short:   "Get volume",
			Long:    cli.Markdown("Get details about target volume"),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetVolume(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-volume volume",
			Short:   "Edit volume",
			Long:    cli.Markdown("Edit target volume"),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2EditVolume(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New volume name")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-zones",
			Short:   "List zones",
			Long:    cli.Markdown("List zones owned by the active org. READ permission required on zone & cloud."),
			Example: examples,
			Group:   "zones",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListZones(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-zone",
			Short:   "Create zone",
			Long:    cli.Markdown("Creates one or more zones on the specified cloud. If async is true, a jobId will be returned. READ permission required on cloud. CREATE_RESOURCES permission required on cloud. CREATE permission required on zone.\n## Request Schema (application/json)\n\nproperties:\n  cloud:\n    description: Specify cloud to provision on\n    type: string\n  dry:\n    description: Return provisioning plan and exit without executing it\n    type: boolean\n  extra:\n    description: Configure additional parameters\n    type: object\n  name:\n    description: Specify zone name\n    type: string\n  save:\n    description: Save provisioning plan as template\n    type: boolean\n  tags:\n    description: Assign tags to provisioned zone\n    type: object\n  template:\n    type: object\nrequired:\n- name\n- cloud\ntype: object\n"),
			Example: examples,
			Group:   "zones",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2CreateZone(params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-zone zone",
			Short:   "Get zone",
			Long:    cli.Markdown("Get details about target zone"),
			Example: examples,
			Group:   "zones",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetZone(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-zone zone",
			Short:   "Edit zone",
			Long:    cli.Markdown("Edit target zone"),
			Example: examples,
			Group:   "zones",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2EditZone(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New zone name")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

}
