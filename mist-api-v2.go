// Code generated by openapi-cli-generator. DO NOT EDIT.
// See https://gitlab.ops.mist.io/mistio/openapi-cli-generator

package main

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/mistio/cobra"
	"github.com/pkg/errors"
	"github.com/spf13/viper"
	"gitlab.ops.mist.io/mistio/openapi-cli-generator/cli"
	terminal "golang.org/x/term"
	"gopkg.in/h2non/gentleman.v2"
)

var mistApiV2Subcommand bool

/*type CLIOutputOptions struct {
    TableDefault   []string
	TableExtended  []string
}*/

func mistApiV2Servers() []map[string]string {
	return []map[string]string{

		map[string]string{
			"description": "Mist Hosted Service",
			"url":         "https://mist.io/",
		},
	}
}

func setMistContext() error {
	mistContext := viper.GetString("context")
	mistContextDefault := cli.Creds.GetString("default.context")
	if mistContext == "" {
		if mistContextDefault == "" {
			mistContexts := cli.Creds.GetStringMap("contexts")
			if len(mistContexts) == 0 {
				return errors.Errorf("No contexts configured. Use `%s config add-context` to add one.", cli.Root.CommandPath())
			}
			for k, _ := range mistContexts {
				mistContext = k
				break
			}
		} else {
			mistContext = mistContextDefault
		}
	}
	if cli.ExistsMistContext(mistContext) {
		viper.Set("context", mistContext)
		if mistContextDefault == "" {
			cli.UpdateDefaultMistContext(mistContext)
		}
		return nil
	}
	return errors.Errorf("Context %s not configured. Use `%s config add-context` to add it.", mistContext, cli.Root.CommandPath())
}

func getServer() (string, error) {
	server := viper.GetString("server")
	if server == "" {
		var ok bool
		server, ok = cli.GetMistContext()["server"]
		if !ok {
			server = cli.Creds.GetString("default.server")
			if server == "" {
				if len(mistApiV2Servers()) > 0 {
					server = mistApiV2Servers()[0]["url"]
					cli.UpdateDefaultServer(server)
				} else {
					return "", errors.Errorf("No default server url found.")
				}
			}
		}
	}
	return server, nil
}

func getToken() (string, error) {
	err := setMistContext()
	if err != nil {
		return "", err
	}
	mistContext := cli.Creds.GetString("default.context")
	return cli.Creds.GetString("contexts." + mistContext + ".api_key"), nil
}

// MistApiV2ListClouds List clouds
func MistApiV2ListClouds(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-clouds"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds"

	req := cli.Client.Get().URL(url)

	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"id", "title", "provider", "tags"}, []string{"id", "title", "provider", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2AddCloud Add cloud
func MistApiV2AddCloud(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "add-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetCloud Get cloud
func MistApiV2GetCloud(paramCloud string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds/{cloud}"
	url = strings.Replace(url, "{cloud}", paramCloud, 1)

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteCloud Delete cloud
func MistApiV2DeleteCloud(paramCloud string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds/{cloud}"
	url = strings.Replace(url, "{cloud}", paramCloud, 1)

	req := cli.Client.Delete().URL(url)

	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListKeys List keys
func MistApiV2ListKeys(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-keys"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds/{cloud}"
	url = strings.Replace(url, "{cloud}", paramCloud, 1)

	req := cli.Client.Put().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return resp, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}, []string{}, []string{}}, nil
}

// MistApiV2CreateCluster Create cluster
func MistApiV2CreateCluster(params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-cluster"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clusters"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2AddKey Add key
func MistApiV2AddKey(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "add-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clusters"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteKey Delete key
func MistApiV2DeleteKey(paramKey string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clusters/{cluster}"
	url = strings.Replace(url, "{cluster}", paramCluster, 1)

	req := cli.Client.Get().URL(url)

	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetKey Get key
func MistApiV2GetKey(paramKey string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clusters/{cluster}"
	url = strings.Replace(url, "{cluster}", paramCluster, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2EditKey Edit key
func MistApiV2EditKey(paramKey string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/datapoints"

	req := cli.Client.Get().URL(url)

	req = req.AddQuery("query", paramQuery)

	paramTags := params.GetString("tags")
	if paramTags != "" {
		req = req.AddQuery("tags", fmt.Sprintf("%v", paramTags))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramEnd := params.GetString("end")
	if paramEnd != "" {
		req = req.AddQuery("end", fmt.Sprintf("%v", paramEnd))
	}
	paramStep := params.GetString("step")
	if paramStep != "" {
		req = req.AddQuery("step", fmt.Sprintf("%v", paramStep))
	}
	paramTime := params.GetString("time")
	if paramTime != "" {
		req = req.AddQuery("time", fmt.Sprintf("%v", paramTime))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListRules List rules
func MistApiV2ListRules(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-rules"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/images"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2AddRule Add rule
func MistApiV2AddRule(paramQueries string, paramWindow string, paramFrequency string, paramTriggerAfter string, paramActions string, paramSelectors string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "add-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/images/{image}"
	url = strings.Replace(url, "{image}", paramImage, 1)

	req := cli.Client.Get().URL(url)

	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ToggleRule Toggle rule
func MistApiV2ToggleRule(paramRule string, paramAction string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "toggle-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Put().URL(url)

	req = req.AddQuery("action", paramAction)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteRule Delete rule
func MistApiV2DeleteRule(paramRule string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/jobs/{job_id}"
	url = strings.Replace(url, "{job_id}", paramJobId, 1)

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetRule Get rule
func MistApiV2GetRule(paramRule string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	url := server + "/api/v2/keys"

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return resp, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2RenameRule Rename rule
func MistApiV2RenameRule(paramRule string, paramAction string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "rename-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/keys"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return resp, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}, []string{}, []string{}}, nil
}

// MistApiV2DeleteKey Delete key
func MistApiV2DeleteKey(paramKey string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/keys/{key}"
	url = strings.Replace(url, "{key}", paramKey, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2UpdateRule Update rule
func MistApiV2UpdateRule(paramRule string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "update-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/keys/{key}"
	url = strings.Replace(url, "{key}", paramKey, 1)

	req := cli.Client.Get().URL(url)

	paramPrivate := params.GetBool("private")
	if paramPrivate != false {
		req = req.AddQuery("private", fmt.Sprintf("%v", paramPrivate))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return resp, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "default", "tags"}, []string{"id", "name", "default", "tags", "owned_by", "created_by"}, []string{}, []string{}}, nil
}

// MistApiV2EditKey Edit key
func MistApiV2EditKey(paramKey string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/keys/{key}"
	url = strings.Replace(url, "{key}", paramKey, 1)

	req := cli.Client.Put().URL(url)

	paramName := params.GetString("name")
	if paramName != "" {
		req = req.AddQuery("name", fmt.Sprintf("%v", paramName))
	}
	paramDefault := params.GetBool("default")
	if paramDefault != false {
		req = req.AddQuery("default", fmt.Sprintf("%v", paramDefault))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

		cmd := &cobra.Command{
			Use:     "update-rule rule",
			Short:   "Update rule",
			Long:    cli.Markdown("Update a rule given its UUID, EDIT permission required on rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListSecrets List secrets
func MistApiV2ListSecrets(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-secrets"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

			},
		}
		root.AddCommand(cmd)

	url := server + "/api/v2/secrets"

	req := cli.Client.Get().URL(url)

	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"id", "name", "tags"}, []string{"id", "name", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2CreateSecret Create secret
func MistApiV2CreateSecret(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-secret"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/secrets"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	func() {
		params := viper.New()

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteSecret Delete secret
func MistApiV2DeleteSecret(paramSecret string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-secret"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/secrets/{secret}"
	url = strings.Replace(url, "{secret}", paramSecret, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

		cmd := &cobra.Command{
			Use:     "toggle-rule rule action",
			Short:   "Toggle rule",
			Long:    cli.Markdown("Enable or disable a rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[2:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetSecret Get secret
func MistApiV2GetSecret(paramSecret string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-secret"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/secrets/{secret}"
	url = strings.Replace(url, "{secret}", paramSecret, 1)

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("only", "", "Only return these fields")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "rename-rule rule action",
			Short:   "Rename rule",
			Long:    cli.Markdown("Rename a rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[2:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2RenameRule(args[0], args[1], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					logger.Fatalf("Formatting failed: %s", err.Error())
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-scripts",
			Short:   "List scripts",
			Long:    cli.Markdown("List scripts owned by the active org. READ permission required on script."),
			Example: examples,
			Group:   "scripts",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListClouds(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-script script",
			Short:   "Delete script",
			Long:    cli.Markdown("Delete target script"),
			Example: examples,
			Group:   "scripts",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2AddCloud(params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-cloud cloud",
			Short:   "Get cloud",
			Long:    cli.Markdown("Get details about target cloud"),
			Example: examples,
			Group:   "scripts",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetCloud(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-cloud cloud",
			Short:   "Delete cloud",
			Long:    cli.Markdown("Delete target cloud"),
			Example: examples,
			Group:   "scripts",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2DeleteCloud(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New script name")
		cmd.Flags().String("description", "", "New script description")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-sizes",
			Short:   "List sizes",
			Long:    cli.Markdown("List sizes owned by the active org. READ permission required on size & cloud."),
			Example: examples,
			Group:   "sizes",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListKeys(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-size size",
			Short:   "Get size",
			Long:    cli.Markdown("Get details about target size"),
			Example: examples,
			Group:   "sizes",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2AddKey(params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-users",
			Short:   "List users",
			Long:    cli.Markdown("Return current user if requester is not admin. Return all users for admin."),
			Example: examples,
			Group:   "users",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2DeleteKey(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-volume",
			Short:   "Create volume",
			Long:    cli.Markdown("Creates one or more volumes on the specified cloud. If async is true, a jobId will be returned. READ permission required on cloud. CREATE_RESOURCES permission required on cloud. READ permission required on location. CREATE_RESOURCES permission required on location. CREATE permission required on volume.\n## Request Schema (application/json)\n\nproperties:\n  cloud:\n    description: Specify cloud to provision on\n    type: string\n  dry:\n    description: Return provisioning plan and exit without executing it\n    type: boolean\n  extra:\n    description: Configure additional parameters\n    type: object\n  location:\n    description: Where to provision e.g. region, datacenter, rack\n    type: string\n  name:\n    description: Specify volume name\n    type: string\n  provider:\n    $ref: '#/components/schemas/SupportedProviders'\n  quantity:\n    description: Provision multiple volumes of this type\n    type: number\n  save:\n    description: Save provisioning plan as template\n    type: boolean\n  size:\n    description: Volume sizing spec\n    type: object\n  tags:\n    description: Assign tags to provisioned volume\n    type: object\n  template:\n    type: object\nrequired:\n- name\n- size\ntype: object\n"),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2GetKey(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-volumes",
			Short:   "List volumes",
			Long:    cli.Markdown("List volumes owned by the active org. READ permission required on volume & cloud."),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2EditKey(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-volume volume",
			Short:   "Delete volume",
			Long:    cli.Markdown("Delete target volume"),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListRules(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-volume volume",
			Short:   "Get volume",
			Long:    cli.Markdown("Get details about target volume"),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2AddRule(args[0], args[1], args[2], args[3], args[4], args[5], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "toggle-rule rule action",
			Short:   "Toggle rule",
			Long:    cli.Markdown("Enable or disable a rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[2:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2ToggleRule(args[0], args[1], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-volume volume",
			Short:   "Edit volume",
			Long:    cli.Markdown("Edit target volume"),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2DeleteRule(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New volume name")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-zones",
			Short:   "List zones",
			Long:    cli.Markdown("List zones owned by the active org. READ permission required on zone & cloud."),
			Example: examples,
			Group:   "zones",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetRule(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-zone",
			Short:   "Create zone",
			Long:    cli.Markdown("Creates one or more zones on the specified cloud. If async is true, a jobId will be returned. READ permission required on cloud. CREATE_RESOURCES permission required on cloud. CREATE permission required on zone.\n## Request Schema (application/json)\n\nproperties:\n  cloud:\n    description: Specify cloud to provision on\n    type: string\n  dry:\n    description: Return provisioning plan and exit without executing it\n    type: boolean\n  extra:\n    description: Configure additional parameters\n    type: object\n  name:\n    description: Specify zone name\n    type: string\n  save:\n    description: Save provisioning plan as template\n    type: boolean\n  tags:\n    description: Assign tags to provisioned zone\n    type: object\n  template:\n    type: object\nrequired:\n- name\n- cloud\ntype: object\n"),
			Example: examples,
			Group:   "zones",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2RenameRule(args[0], args[1], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-zone zone",
			Short:   "Edit zone",
			Long:    cli.Markdown("Edit target zone"),
			Example: examples,
			Group:   "zones",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2UpdateRule(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New zone name")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-secrets",
			Short:   "List secrets",
			Long:    cli.Markdown("List secrets owned by the active org. READ permission required on secret."),
			Example: examples,
			Group:   "secrets",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListSecrets(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-secret",
			Short:   "Create secret",
			Long:    cli.Markdown("Creates a new secret and returns the secret's id. CREATE permission required on secret.\n## Request Schema (application/json)\n\nproperties:\n  name:\n    description: The name of the secret. This is equivalent to the path the secret\n      will be stored in Vault\n    type: string\n  secret:\n    type: object\nrequired:\n- name\n- secret\ntype: object\n"),
			Example: examples,
			Group:   "secrets",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2CreateSecret(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-secret secret",
			Short:   "Delete secret",
			Long:    cli.Markdown("Delete target secret"),
			Example: examples,
			Group:   "secrets",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2DeleteSecret(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-secret secret",
			Short:   "Get secret",
			Long:    cli.Markdown("Read target secret"),
			Example: examples,
			Group:   "secrets",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetSecret(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

}
