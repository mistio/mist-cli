// Code generated by openapi-cli-generator. DO NOT EDIT.
// See https://gitlab.ops.mist.io/mistio/openapi-cli-generator

package main

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/mistio/cobra"
	"github.com/pkg/errors"
	"github.com/spf13/viper"
	"gitlab.ops.mist.io/mistio/openapi-cli-generator/cli"
	terminal "golang.org/x/term"
	"gopkg.in/h2non/gentleman.v2"
)

var mistApiV2Subcommand bool

/*type CLIOutputOptions struct {
    TableDefault   []string
	TableExtended  []string
}*/

func mistApiV2Servers() []map[string]string {
	return []map[string]string{

		map[string]string{
			"description": "Mist Hosted Service",
			"url":         "https://mist.io/",
		},
	}
}

// MistApiV2ListClouds List clouds
func MistApiV2ListClouds(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-clouds"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/clouds"

	req := cli.Client.Get().URL(url)

	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"title", "provider", "tags"}, []string{"id", "title", "provider", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2AddCloud Add cloud
func MistApiV2AddCloud(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "add-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2EditCloud Edit cloud
func MistApiV2EditCloud(paramCloud string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds/{cloud}"
	url = strings.Replace(url, "{cloud}", paramCloud, 1)

	req := cli.Client.Put().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteCloud Delete cloud
func MistApiV2DeleteCloud(paramCloud string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds/{cloud}"
	url = strings.Replace(url, "{cloud}", paramCloud, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetCloud Get cloud
func MistApiV2GetCloud(paramCloud string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-cloud"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds/{cloud}"
	url = strings.Replace(url, "{cloud}", paramCloud, 1)

	req := cli.Client.Get().URL(url)

	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"title", "provider", "tags"}, []string{"id", "title", "provider", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2ListKeys List keys
func MistApiV2ListKeys(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-keys"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clouds/{cloud}"
	url = strings.Replace(url, "{cloud}", paramCloud, 1)

	req := cli.Client.Put().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return resp, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}, []string{}, []string{}}, nil
}

// MistApiV2CreateCluster Create cluster
func MistApiV2CreateCluster(params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-cluster"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clusters"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "default", "tags"}, []string{"name", "default", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2AddKey Add key
func MistApiV2AddKey(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "add-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clusters"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteKey Delete key
func MistApiV2DeleteKey(paramKey string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clusters/{cluster}"
	url = strings.Replace(url, "{cluster}", paramCluster, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetKey Get key
func MistApiV2GetKey(paramKey string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/clusters/{cluster}"
	url = strings.Replace(url, "{cluster}", paramCluster, 1)

	req := cli.Client.Get().URL(url)

	paramPrivate := params.GetBool("private")
	if paramPrivate != false {
		req = req.AddQuery("private", fmt.Sprintf("%v", paramPrivate))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "default", "tags"}, []string{"id", "name", "default", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2EditKey Edit key
func MistApiV2EditKey(paramKey string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-key"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	server, err := getServer()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	req := cli.Client.Put().URL(url)

	paramName := params.GetString("name")
	if paramName != "" {
		req = req.AddQuery("name", fmt.Sprintf("%v", paramName))
	}
	paramDefault := params.GetBool("default")
	if paramDefault != false {
		req = req.AddQuery("default", fmt.Sprintf("%v", paramDefault))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListMachines List machines
func MistApiV2ListMachines(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-machines"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines"

	req := cli.Client.Get().URL(url)

	paramCloud := params.GetString("cloud")
	if paramCloud != "" {
		req = req.AddQuery("cloud", fmt.Sprintf("%v", paramCloud))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}
	paramDeref := params.GetString("deref")
	if paramDeref != "" {
		req = req.AddQuery("deref", fmt.Sprintf("%v", paramDeref))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud", "state", "tags"}, []string{"id", "name", "state", "cloud", "public_ips", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2CreateMachine Create machine
func MistApiV2CreateMachine(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetMachine Get machine
func MistApiV2GetMachine(paramMachine string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "cloud", "tags"}, []string{"id", "name", "default", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2EditMachine Edit machine
func MistApiV2EditMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Put().URL(url)

	paramName := params.GetString("name")
	if paramName != "" {
		req = req.AddQuery("name", fmt.Sprintf("%v", paramName))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return resp, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}, []string{}, []string{}}, nil
}

// MistApiV2CloneMachine Clone machine
func MistApiV2CloneMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "clone-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/clone"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2Console Open console
func MistApiV2Console(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "console"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/console"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return resp, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return resp, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"name", "default", "tags"}, []string{"id", "name", "default", "tags", "owned_by", "created_by"}, []string{}, []string{}}, nil
}

// MistApiV2DestroyMachine Destroy machine
func MistApiV2DestroyMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "destroy-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	err := setMistContext()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, err
	}

	url := server + "/api/v2/machines/{machine}/actions/destroy"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ExposeMachine Expose machine
func MistApiV2ExposeMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "expose-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/actions/expose"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2RebootMachine Reboot machine
func MistApiV2RebootMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "reboot-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

			},
		}
		root.AddCommand(cmd)

	url := server + "/api/v2/machines/{machine}/actions/reboot"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2RenameMachine Rename machine
func MistApiV2RenameMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "rename-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/actions/rename"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ResizeMachine Resize machine
func MistApiV2ResizeMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "resize-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/actions/resize"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	func() {
		params := viper.New()

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ResumeMachine Resume machine
func MistApiV2ResumeMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "resume-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/actions/resume"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2Ssh Open secure shell
func MistApiV2Ssh(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "ssh"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/actions/ssh"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2StartMachine Start machine
func MistApiV2StartMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "start-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/actions/start"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2StopMachine Stop machine
func MistApiV2StopMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "stop-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/actions/stop"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2SuspendMachine Suspend machine
func MistApiV2SuspendMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "suspend-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/actions/suspend"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2UndefineMachine Undefine machine
func MistApiV2UndefineMachine(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "undefine-machine"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/actions/undefine"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListSnapshots Suspend machine
func MistApiV2ListSnapshots(paramMachine string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-snapshots"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/snapshots"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2CreateSnapshot Create snapshot
func MistApiV2CreateSnapshot(paramMachine string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-snapshot"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/snapshots"
	url = strings.Replace(url, "{machine}", paramMachine, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2RemoveSnapshot Remove snapshot
func MistApiV2RemoveSnapshot(paramMachine string, paramSnapshot string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "remove-snapshot"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/snapshots/{snapshot}"
	url = strings.Replace(url, "{machine}", paramMachine, 1)
	url = strings.Replace(url, "{snapshot}", paramSnapshot, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2RevertToSnapshot Revert to snapshot
func MistApiV2RevertToSnapshot(paramMachine string, paramSnapshot string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "revert-to-snapshot"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/machines/{machine}/snapshots/{snapshot}"
	url = strings.Replace(url, "{machine}", paramMachine, 1)
	url = strings.Replace(url, "{snapshot}", paramSnapshot, 1)

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListRules List rules
func MistApiV2ListRules(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-rules"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/rules"

	req := cli.Client.Get().URL(url)

	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"title", "queries", "actions", "tags"}, []string{"id", "title", "resource_type", "selectors", "queries", "actions", "window", "frequency", "tags"}}, nil
}

// MistApiV2AddRule Add rule
func MistApiV2AddRule(paramQueries string, paramWindow string, paramFrequency string, paramTriggerAfter string, paramActions string, paramSelectors string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "add-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/rules"

	req := cli.Client.Post().URL(url)

	req = req.AddQuery("queries", paramQueries)

	req = req.AddQuery("window", paramWindow)

	req = req.AddQuery("frequency", paramFrequency)

	req = req.AddQuery("trigger_after", paramTriggerAfter)

	req = req.AddQuery("actions", paramActions)

	req = req.AddQuery("selectors", paramSelectors)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteRule Delete rule
func MistApiV2DeleteRule(paramRule string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetRule Get rule
func MistApiV2GetRule(paramRule string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Get().URL(url)

	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"title", "queries", "actions", "tags"}, []string{"id", "title", "resource_type", "selectors", "queries", "actions", "window", "frequency", "tags"}}, nil
}

// MistApiV2RenameRule Rename rule
func MistApiV2RenameRule(paramRule string, paramAction string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "rename-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Patch().URL(url)

	req = req.AddQuery("action", paramAction)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2UpdateRule Update rule
func MistApiV2UpdateRule(paramRule string, params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "update-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Post().URL(url)

	paramQueries := params.GetString("queries")
	if paramQueries != "" {
		req = req.AddQuery("queries", fmt.Sprintf("%v", paramQueries))
	}
	paramWindow := params.GetString("window")
	if paramWindow != "" {
		req = req.AddQuery("window", fmt.Sprintf("%v", paramWindow))
	}
	paramFrequency := params.GetString("frequency")
	if paramFrequency != "" {
		req = req.AddQuery("frequency", fmt.Sprintf("%v", paramFrequency))
	}
	paramTriggerAfter := params.GetString("trigger-after")
	if paramTriggerAfter != "" {
		req = req.AddQuery("trigger_after", fmt.Sprintf("%v", paramTriggerAfter))
	}
	paramActions := params.GetString("actions")
	if paramActions != "" {
		req = req.AddQuery("actions", fmt.Sprintf("%v", paramActions))
	}
	paramSelectors := params.GetString("selectors")
	if paramSelectors != "" {
		req = req.AddQuery("selectors", fmt.Sprintf("%v", paramSelectors))
	}

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ToggleRule Toggle rule
func MistApiV2ToggleRule(paramRule string, paramAction string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "toggle-rule"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/rules/{rule}"
	url = strings.Replace(url, "{rule}", paramRule, 1)

	req := cli.Client.Put().URL(url)

	req = req.AddQuery("action", paramAction)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2ListSecrets List secrets
func MistApiV2ListSecrets(params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "list-secrets"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/secrets"

	req := cli.Client.Get().URL(url)

	paramCached := params.GetBool("cached")
	if paramCached != false {
		req = req.AddQuery("cached", fmt.Sprintf("%v", paramCached))
	}
	paramPath := params.GetString("path")
	if paramPath != "" {
		req = req.AddQuery("path", fmt.Sprintf("%v", paramPath))
	}
	paramSearch := params.GetString("search")
	if paramSearch != "" {
		req = req.AddQuery("search", fmt.Sprintf("%v", paramSearch))
	}
	paramSort := params.GetString("sort")
	if paramSort != "" {
		req = req.AddQuery("sort", fmt.Sprintf("%v", paramSort))
	}
	paramStart := params.GetString("start")
	if paramStart != "" {
		req = req.AddQuery("start", fmt.Sprintf("%v", paramStart))
	}
	paramLimit := params.GetInt64("limit")
	if paramLimit != 0 {
		req = req.AddQuery("limit", fmt.Sprintf("%v", paramLimit))
	}
	paramOnly := params.GetString("only")
	if paramOnly != "" {
		req = req.AddQuery("only", fmt.Sprintf("%v", paramOnly))
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{"id", "name", "tags"}, []string{"id", "name", "tags", "owned_by", "created_by"}}, nil
}

// MistApiV2CreateSecret Create secret
func MistApiV2CreateSecret(params *viper.Viper, body string) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "create-secret"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/secrets"

	req := cli.Client.Post().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "application/json").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2EditSecret Edit secret
func MistApiV2EditSecret(paramSecret string, params *viper.Viper, body string) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "edit-secret"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/secrets/{secret}"
	url = strings.Replace(url, "{secret}", paramSecret, 1)

	req := cli.Client.Put().URL(url)

	if body != "" {
		req = req.AddHeader("Content-Type", "").BodyString(body)
	}

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2DeleteSecret Delete secret
func MistApiV2DeleteSecret(paramSecret string, params *viper.Viper) (*gentleman.Response, interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "delete-secret"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/secrets/{secret}"
	url = strings.Replace(url, "{secret}", paramSecret, 1)

	req := cli.Client.Delete().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

// MistApiV2GetSecret Get secret
func MistApiV2GetSecret(paramSecret string, params *viper.Viper) (*gentleman.Response, map[string]interface{}, cli.CLIOutputOptions, error) {
	handlerPath := "get-secret"
	if mistApiV2Subcommand {
		handlerPath = "Mist CLI " + handlerPath
	}

	server := viper.GetString("server")
	if server == "" {
		server = mistApiV2Servers()[viper.GetInt("server-index")]["url"]
	}

	url := server + "/api/v2/secrets/{secret}"
	url = strings.Replace(url, "{secret}", paramSecret, 1)

	req := cli.Client.Get().URL(url)

	cli.HandleBefore(handlerPath, params, req)

	resp, err := req.Do()
	if err != nil {
		return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Request failed")
	}

	var decoded map[string]interface{}

	if resp.StatusCode < 400 {
		if err := cli.UnmarshalResponse(resp, &decoded); err != nil {
			return nil, nil, cli.CLIOutputOptions{}, errors.Wrap(err, "Unmarshalling response failed")
		}
	} else {
		return nil, nil, cli.CLIOutputOptions{}, errors.Errorf("HTTP %d: %s", resp.StatusCode, resp.String())
	}

	after := cli.HandleAfter(handlerPath, params, resp, decoded)
	if after != nil {
		decoded = after.(map[string]interface{})
	}

	return resp, decoded, cli.CLIOutputOptions{[]string{}, []string{}}, nil
}

func mistApiV2Register(subcommand bool) {
	root := cli.Root

	if subcommand {
		root = &cobra.Command{
			Use:   "Mist CLI",
			Short: "Mist API",
			Long:  cli.Markdown(""),
		}
		mistApiV2Subcommand = true
	} else {
		cli.Root.Short = "Mist API"
		cli.Root.Long = cli.Markdown("")
	}

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-clouds",
			Short:   "List clouds",
			Long:    cli.Markdown("List clouds owned by the active org. READ permission required on cloud."),
			Example: examples,
			Group:   "clouds",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListClouds(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "add-cloud",
			Short:   "Add cloud",
			Long:    cli.Markdown("Adds a new cloud and returns the cloud's id. ADD permission required on cloud.\n## Request Schema (application/json)\n\nproperties:\n  credentials:\n    $ref: '#/components/schemas/CloudCredentials'\n  features:\n    $ref: '#/components/schemas/CloudFeatures'\n  provider:\n    description: The provider of the cloud\n    enum:\n    - amazon\n    - digitalocean\n    - google\n    - openstack\n    - packet\n    - vsphere\n    type: string\n  title:\n    description: The name of the cloud to add\n    type: string\nrequired:\n- title\n- provider\n- credentials\ntype: object\n"),
			Example: examples,
			Group:   "clouds",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2AddCloud(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-cloud cloud",
			Short:   "Edit cloud",
			Long:    cli.Markdown("Update target cloud title or credentials\n## Request Schema (application/json)\n\nproperties:\n  credentials:\n    $ref: '#/components/schemas/CloudCredentials'\n  features:\n    $ref: '#/components/schemas/CloudFeatures'\n  title:\n    description: Updated title\n    type: string\ntype: object\n"),
			Example: examples,
			Group:   "clouds",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2EditCloud(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-cloud cloud",
			Short:   "Delete cloud",
			Long:    cli.Markdown("Delete target cloud"),
			Example: examples,
			Group:   "clouds",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2DeleteCloud(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-cloud cloud",
			Short:   "Get cloud",
			Long:    cli.Markdown("Get details about target cloud"),
			Example: examples,
			Group:   "clouds",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetCloud(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-keys",
			Short:   "List keys",
			Long:    cli.Markdown("List keys owned by the active org. READ permission required on key."),
			Example: examples,
			Group:   "keys",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListKeys(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "add-key",
			Short:   "Add key",
			Long:    cli.Markdown("Adds a new key and returns the key's id. ADD permission required on key.\n## Request Schema (application/json)\n\nanyOf:\n- properties:\n    certificate:\n      description: The signed public key, when using signed ssh keys\n      type: string\n    name:\n      description: The key's name\n      type: string\n    private:\n      description: The private key\n      type: string\n  required:\n  - name\n  - private\n- properties:\n    dry:\n      description: Return generated key without actually adding it\n      type: boolean\n    generate:\n      description: Generate a keypair instead of providing one\n      type: boolean\n    name:\n      description: The key's name\n      type: string\n  required:\n  - name\n  - generate\n- properties:\n    dry:\n      description: Return generated key without actually adding it\n      type: boolean\n    generate:\n      description: Generate a keypair instead of providing one\n      type: boolean\n  required:\n  - generate\n  - dry\ntype: object\n"),
			Example: examples,
			Group:   "keys",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2AddKey(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-key key",
			Short:   "Delete key",
			Long:    cli.Markdown("Delete target key"),
			Example: examples,
			Group:   "keys",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2DeleteKey(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-key key",
			Short:   "Get key",
			Long:    cli.Markdown("Get details about target key"),
			Example: examples,
			Group:   "keys",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetKey(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("private", "", "Return the private key. Requires READ_PRIVATE permission on key.")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-key key",
			Short:   "Edit key",
			Long:    cli.Markdown("Edit target key"),
			Example: examples,
			Group:   "keys",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2EditKey(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New key name")
		cmd.Flags().String("default", "", "Set as default")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-machines",
			Short:   "List machines",
			Long:    cli.Markdown("List machines owned by the active org. READ permission required on machine & cloud."),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListMachines(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-machine",
			Short:   "Create machine",
			Long:    cli.Markdown("Creates one or more machines on the specified cloud. If async is true, a jobId will be returned. READ permission required on cloud. CREATE_RESOURCES permission required on cloud. READ permission required on location. CREATE_RESOURCES permission required on location. CREATE permission required on machine. RUN permission required on script. READ permission required on key.\n## Request Schema (application/json)\n\nproperties:\n  cloud:\n    description: Specify cloud to provision on\n    type: string\n  cloudinit:\n    description: Run this Cloud Init script on first boot\n    type: string\n  disks:\n    description: Configure local disks\n    type: object\n  dry:\n    description: Return provisioning plan and exit without executing it\n    type: boolean\n  expiration:\n    description: Configure machine expiration\n    type: object\n  extra:\n    description: Configure additional parameters\n    type: object\n  fqdn:\n    description: Add DNS A Record that points machine's public IP to this Fully Qualified\n      Domain Name. Zone needs to be managed by a configured Cloud DNS provider\n    type: string\n  image:\n    description: Operating System image to boot from\n    type: object\n  key:\n    description: Associate SSH key\n    type: object\n  location:\n    description: Where to provision e.g. region, datacenter, rack\n    type: string\n  monitoring:\n    description: Enable monitoring of this machine\n    type: boolean\n  name:\n    description: Specify machine name\n    type: string\n  net:\n    description: Specify network configuration parameters\n    type: object\n  provider:\n    $ref: '#/components/schemas/SupportedProviders'\n  quantity:\n    description: Provision multiple machines of this type\n    type: number\n  save:\n    description: Save provisioning plan as template\n    type: boolean\n  schedules:\n    description: Configure scheduled actions for the provisioned machine\n    type: object\n  scripts:\n    description: Run post deploy scripts over SSH\n    items:\n      type: object\n    type: array\n  size:\n    description: Machine sizing spec e.g. cpu/ram/flavor\n    type: object\n  tags:\n    description: Assign tags to provisioned machine\n    type: object\n  template:\n    type: object\n  volumes:\n    description: Configure of attached storage volumes, e.g. cloud disks\n    items:\n      type: object\n    type: array\nrequired:\n- name\n- size\n- image\ntype: object\n"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2CreateMachine(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-machine machine",
			Short:   "Get machine",
			Long:    cli.Markdown("Get details about target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetMachine(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-machine machine",
			Short:   "Edit machine",
			Long:    cli.Markdown("Edit target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2EditMachine(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New machine name")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "clone-machine machine",
			Short:   "Clone machine",
			Long:    cli.Markdown("Clone target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2CloneMachine(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "console machine",
			Short:   "Open console",
			Long:    cli.Markdown("Open VNC console on target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2Console(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "destroy-machine machine",
			Short:   "Destroy machine",
			Long:    cli.Markdown("Destroy target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2DestroyMachine(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "expose-machine machine",
			Short:   "Expose machine",
			Long:    cli.Markdown("Expose target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2ExposeMachine(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "reboot-machine machine",
			Short:   "Reboot machine",
			Long:    cli.Markdown("Reboot target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2RebootMachine(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "rename-machine machine",
			Short:   "Rename machine",
			Long:    cli.Markdown("Rename target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2RenameMachine(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "resize-machine machine",
			Short:   "Resize machine",
			Long:    cli.Markdown("Resize target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2ResizeMachine(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("only", "", "Only return these fields")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "resume-machine machine",
			Short:   "Resume machine",
			Long:    cli.Markdown("Resume target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2ResumeMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "ssh machine",
			Short:   "Open secure shell",
			Long:    cli.Markdown("Open secure shell on target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2Ssh(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "start-machine machine",
			Short:   "Start machine",
			Long:    cli.Markdown("Start target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2StartMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "stop-machine machine",
			Short:   "Stop machine",
			Long:    cli.Markdown("Stop target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2StopMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("name", "", "New script name")
		cmd.Flags().String("description", "", "New script description")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "suspend-machine machine",
			Short:   "Suspend machine",
			Long:    cli.Markdown("Suspend target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2SuspendMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "undefine-machine machine",
			Short:   "Undefine machine",
			Long:    cli.Markdown("Undefine target machine"),
			Example: examples,
			Group:   "machines",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2UndefineMachine(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-snapshots machine",
			Short:   "Suspend machine",
			Long:    cli.Markdown("List snapshots of target machine"),
			Example: examples,
			Group:   "snapshots",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListSnapshots(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-snapshot machine",
			Short:   "Create snapshot",
			Long:    cli.Markdown("Create snapshots of target machine"),
			Example: examples,
			Group:   "snapshots",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2CreateSnapshot(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "remove-snapshot machine snapshot",
			Short:   "Remove snapshot",
			Long:    cli.Markdown("Remove target machine snapshot"),
			Example: examples,
			Group:   "snapshots",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2RemoveSnapshot(args[0], args[1], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "revert-to-snapshot machine snapshot",
			Short:   "Revert to snapshot",
			Long:    cli.Markdown("Revert machine to snapshot"),
			Example: examples,
			Group:   "snapshots",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[2:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2RevertToSnapshot(args[0], args[1], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cloud", "", "")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-volume volume",
			Short:   "Delete volume",
			Long:    cli.Markdown("Delete target volume"),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListRules(params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-volume volume",
			Short:   "Get volume",
			Long:    cli.Markdown("Get details about target volume"),
			Example: examples,
			Group:   "volumes",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2AddRule(args[0], args[1], args[2], args[3], args[4], args[5], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-rule rule",
			Short:   "Delete rule",
			Long:    cli.Markdown("Delete a rule given its UUID."),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2DeleteRule(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-rule rule",
			Short:   "Get rule",
			Long:    cli.Markdown("Get details about target rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetRule(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("only", "", "Only return these fields")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "rename-rule rule action",
			Short:   "Rename rule",
			Long:    cli.Markdown("Rename a rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[2:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2RenameRule(args[0], args[1], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "update-rule rule",
			Short:   "Update rule",
			Long:    cli.Markdown("Update a rule given its UUID, EDIT permission required on rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2UpdateRule(args[0], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("queries", "", "")
		cmd.Flags().String("window", "", "")
		cmd.Flags().String("frequency", "", "")
		cmd.Flags().String("trigger-after", "", "")
		cmd.Flags().String("actions", "", "")
		cmd.Flags().String("selectors", "", "")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "toggle-rule rule action",
			Short:   "Toggle rule",
			Long:    cli.Markdown("Enable or disable a rule"),
			Example: examples,
			Group:   "rules",
			Args:    cobra.MinimumNArgs(2),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[2:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2ToggleRule(args[0], args[1], params, body)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "list-secrets",
			Short:   "List secrets",
			Long:    cli.Markdown("List secrets owned by the active org. READ permission required on secret."),
			Example: examples,
			Group:   "secrets",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2ListSecrets(params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("cached", "", "Only return cached secrets if set to true")
		cmd.Flags().String("path", "", "Only return secrets under this path")
		cmd.Flags().String("search", "", "Only return results matching search filter")
		cmd.Flags().String("sort", "", "Order results by")
		cmd.Flags().String("start", "", "Start results from index or id")
		cmd.Flags().Int64("limit", 0, "Limit number of results, 1000 max")
		cmd.Flags().String("only", "", "Only return these fields")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "create-secret",
			Short:   "Create secret",
			Long:    cli.Markdown("Creates a new secret and returns the secret's id. CREATE permission required on secret.\n## Request Schema (application/json)\n\nproperties:\n  name:\n    description: The name of the secret. This is equivalent to the path the secret\n      will be stored in Vault\n    type: string\n  secret:\n    type: object\nrequired:\n- name\n- secret\ntype: object\n"),
			Example: examples,
			Group:   "secrets",
			Args:    cobra.MinimumNArgs(0),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("application/json", args[0:])
				if err != nil {
					logger.Fatalf("Unable to get body: %s", err.Error())
				}

				_, decoded, outputOptions, err := MistApiV2CreateSecret(params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "edit-secret secret",
			Short:   "Edit secret",
			Long:    cli.Markdown("Edit/update target secret"),
			Example: examples,
			Group:   "secrets",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {
				body, err := cli.GetBody("", args[1:])
				if err != nil {
					log.Fatal().Err(err).Msg("Unable to get body")
				}

				_, decoded, outputOptions, err := MistApiV2EditSecret(args[0], params, body)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "delete-secret secret",
			Short:   "Delete secret",
			Long:    cli.Markdown("Delete target secret"),
			Example: examples,
			Group:   "secrets",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2DeleteSecret(args[0], params)
				if err != nil {
					log.Fatal().Err(err).Msg("Error calling operation")
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

	func() {
		params := viper.New()

		var examples string

		cmd := &cobra.Command{
			Use:     "get-secret secret",
			Short:   "Get secret",
			Long:    cli.Markdown("Read target secret"),
			Example: examples,
			Group:   "secrets",
			Args:    cobra.MinimumNArgs(1),
			Run: func(cmd *cobra.Command, args []string) {

				_, decoded, outputOptions, err := MistApiV2GetSecret(args[0], params)
				if err != nil {
					logger.Fatalf("Error calling operation: %s", err.Error())
				}

				if err := cli.Formatter.Format(decoded, outputOptions); err != nil {
					log.Fatal().Err(err).Msg("Formatting failed")
				}

			},
		}
		root.AddCommand(cmd)

		cmd.Flags().String("only", "", "Only return these fields")
		cmd.Flags().String("deref", "", "Dereference foreign keys")

		cli.SetCustomFlags(cmd)

		if cmd.Flags().HasFlags() {
			params.BindPFlags(cmd.Flags())
		}

	}()

}
